<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="color-scheme" content="dark light">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ¦ŠðŸ•’</title>
    <style>
      html, body {
        width: 100%;
        height: 100%;
      }
      body {
        display: grid;
        grid-template-rows: auto min-content;
        grid-template-columns: repeat(2, 1fr);
        margin: 0;
      }
      #clock {
        aspect-ratio: 1 / 1;
        width: 100%;
        height: 100%;
        place-self: center;
        grid-area: 1 / 1 / 1 / 3;
      }
      #time {
        font-family: monospace;
        font-size: 15vw;
        margin: 0;
        place-self: center;
        grid-area: 2 / 1 / 2 / 3;
      }
      #status {
        font-family: sans-serif;
        margin: 8px;
        place-self: start;
        grid-area: 1 / 1 / 1 / 1;
      }
      #wake-lock {
        font-family: sans-serif;
        margin: 8px;
        align-items: center;
        justify-self: end;
        align-self: start;
        grid-area: 1 / 1 / 2 / 3;
      }
      svg g.numerals text {
        text-anchor: middle;
        dominant-baseline: middle;
        font-size: 10px;
        font-family: sans-serif;
        stroke: none;
      }
      svg {
        fill: black;
        stroke: black;
      }
      @media (prefers-color-scheme: dark) {
        svg {
          fill: white;
          stroke: white;
        }
      }
    </style>
  </head>
  <body>
    <svg id="clock" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
      <circle cx="50" cy="50" r="49" fill="none" stroke-width="1" />
      <g id="hour-marks" stroke-width="1">
        <line x1="50" y1="3" x2="50" y2="8" stroke-width="2" />
        <line x1="50" y1="3" x2="50" y2="6" transform="rotate(6, 50, 50)" />
        <line x1="50" y1="3" x2="50" y2="6" transform="rotate(12, 50, 50)" />
        <line x1="50" y1="3" x2="50" y2="6" transform="rotate(18, 50, 50)" />
        <line x1="50" y1="3" x2="50" y2="6" transform="rotate(24, 50, 50)" />
      </g>
      <use href="#hour-marks" transform="rotate(30, 50, 50)" />
      <use href="#hour-marks" transform="rotate(60, 50, 50)" />
      <use href="#hour-marks" transform="rotate(90, 50, 50)" />
      <use href="#hour-marks" transform="rotate(120, 50, 50)" />
      <use href="#hour-marks" transform="rotate(150, 50, 50)" />
      <use href="#hour-marks" transform="rotate(180, 50, 50)" />
      <use href="#hour-marks" transform="rotate(210, 50, 50)" />
      <use href="#hour-marks" transform="rotate(240, 50, 50)" />
      <use href="#hour-marks" transform="rotate(270, 50, 50)" />
      <use href="#hour-marks" transform="rotate(300, 50, 50)" />
      <use href="#hour-marks" transform="rotate(330, 50, 50)" />
      <g class="numerals">
        <text transform="translate(50, 16)">12</text>
        <text transform="rotate(30, 50, 50), translate(50, 15), rotate(-30)">1</text>
        <text transform="rotate(60, 50, 50), translate(50, 15), rotate(-60)">2</text>
        <text transform="rotate(90, 50, 50), translate(50, 15), rotate(-90)">3</text>
        <text transform="rotate(120, 50, 50), translate(50, 15), rotate(-120)">4</text>
        <text transform="rotate(150, 50, 50), translate(50, 15), rotate(-150)">5</text>
        <text transform="rotate(180, 50, 50), translate(50, 15), rotate(-180)">6</text>
        <text transform="rotate(210, 50, 50), translate(50, 15), rotate(-210)">7</text>
        <text transform="rotate(240, 50, 50), translate(50, 15), rotate(-240)">8</text>
        <text transform="rotate(270, 50, 50), translate(50, 15), rotate(-270)">9</text>
        <text transform="rotate(300, 50, 50), translate(50, 15), rotate(-300)">10</text>
        <text transform="rotate(330, 50, 50), translate(50, 15), rotate(-330)">11</text>
      </g>
      <g id="hour-hand">
        <line x1="50" y1="25" x2="50" y2="50" stroke-width="1" />
        <circle cx="50" cy="50" r="3" />
      </g>
      <g id="minute-hand">
        <line x1="50" y1="12.5" x2="50" y2="50" stroke-width="1" />
      </g>
      <g id="second-hand" fill="red" stroke="red">
        <line x1="50" y1="5" x2="50" y2="50" stroke-width="0.5" />
        <circle cx="50" cy="50" r="1.5" />
      </g>
    </svg>
    <p id="time">??:??:??.?</p>
    <p id="status">
      RTT: <span id="delay">?</span>ms<br>
      Offset: <span id="offset">?</span>ms<br>
    </p>
    <p id="wake-lock" style="display: none">
      <label for="enable-wake-lock">Keep screen on:</label>
      <input type="checkbox" id="enable-wake-lock">
    </p>
    <xmp id="worker-script" style="display: none">
      const kNumSamples = 5;
      const kShortDelay = 1000;
      const kLongDelay = 60000;
      const kSocketTimeout = 10000;
      const timeUrl = new URL('/time', location.origin);
      let timeoutId = 0;
      let delays = [];
      let timeOrigins = [];
      let lastRequest = performance.now();
      let hidden = false;

      function average(array) {
        return array.reduce((a, b) => a + b, 0) / array.length;
      }

      async function detectOffset() {
        timeoutId = undefined;

        try {
          if (performance.now() - lastRequest > kSocketTimeout) {
            // The socket has probably timed out. Establish a new connection
            // before taking a measurement.
            await fetch(timeUrl);
          }

          const requestSent = performance.now();
          const response = await fetch(timeUrl);
          const responseReceived = performance.now();
          const serverTime = await response.json();

          if (hidden) {
            return;
          }

          lastRequest = responseReceived;

          const newDelay = responseReceived - requestSent;
          console.log(`Measured round-trip time of ${newDelay.toFixed(2)}ms.`);
          const newTimeOrigin = ((serverTime - requestSent) + (serverTime - responseReceived)) / 2;
          console.log(`Measured time origin of ${newTimeOrigin}.`);

          if (timeOrigins.length > 0) {
            const oldTimeOrigin = average(timeOrigins);
            if (Math.abs(oldTimeOrigin - newTimeOrigin) > newDelay) {
              console.log('Large clock drift detected, clearing measurement history.');
              delays = [];
              timeOrigins = [];
            }
          }

          if (timeOrigins.length >= kNumSamples) {
            delays.shift();
            timeOrigins.shift();
          }

          delays.push(newDelay);
          timeOrigins.push(newTimeOrigin);

          const delay = average(delays);
          const timeOrigin = average(timeOrigins);
          const timeOriginOffset = performance.timeOrigin - timeOrigin;
          const offset = new Date() - new Date(performance.now() + timeOrigin);

          postMessage({delay, timeOriginOffset, offset});
        } catch (e) {
          console.error('Failed to request time from server.', e);
          timeoutId = setTimeout(detectOffset, kShortDelay);
          return;
        }

        timeoutId = setTimeout(
            detectOffset, timeOrigins.length < kNumSamples ? kShortDelay : kLongDelay);
      }

      self.onmessage = (event) => {
        hidden = event.data.hidden;

        if (hidden) {
          if (timeoutId) {
            console.log('Pausing measurements.');
            clearTimeout(timeoutId);
            timeoutId = undefined;
          }
        } else if (!timeoutId) {
          console.log('Resuming measurements.');
          timeoutId = setTimeout(detectOffset, kShortDelay);
        }
      };

      timeoutId = setTimeout(detectOffset, kShortDelay);
    </xmp>
    <script type="module">
      let timeOrigin = INITIAL_SERVER_TIME - performance.now();

      const workerScript = document.getElementById('worker-script').textContent;
      const blob = new Blob([workerScript], { type: 'application/javascript' });
      const workerScriptUrl = URL.createObjectURL(blob);
      const worker = new Worker(workerScriptUrl, { type: 'module' });
      worker.postMessage({timeOrigin: performance.timeOrigin});
      worker.onmessage = (event) => {
        document.getElementById('delay').textContent = event.data.delay.toFixed(2);
        document.getElementById('offset').textContent = event.data.offset;
        timeOrigin = performance.timeOrigin - event.data.timeOriginOffset;
      }

      const clockEmoji = ['ðŸ•›', 'ðŸ•§', 'ðŸ•', 'ðŸ•œ', 'ðŸ•‘', 'ðŸ•', 'ðŸ•’', 'ðŸ•ž',
        'ðŸ•“', 'ðŸ•Ÿ', 'ðŸ•”', 'ðŸ• ', 'ðŸ••', 'ðŸ•¡', 'ðŸ•–', 'ðŸ•£', 'ðŸ•—', 'ðŸ•¢', 'ðŸ•˜',
        'ðŸ•¤', 'ðŸ•™', 'ðŸ•¥', 'ðŸ•š', 'ðŸ•¦'];

      const clock = document.getElementById('clock');
      const hourTransform = clock.createSVGTransform();
      document.getElementById('hour-hand').transform.baseVal.initialize(hourTransform);
      const minuteTransform = clock.createSVGTransform();
      document.getElementById('minute-hand').transform.baseVal.initialize(minuteTransform);
      const secondTransform = clock.createSVGTransform();
      document.getElementById('second-hand').transform.baseVal.initialize(secondTransform);
      const time = document.getElementById('time');

      function updateTime() {
        const now = new Date(performance.now() + timeOrigin);
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        const tenths = Math.floor(now.getMilliseconds() / 100).toString();
        time.textContent = `${hours}:${minutes}:${seconds}.${tenths}`;

        const emojiIndex = (now.getHours() % 12) * 2 + Math.floor(now.getMinutes() / 30);
        const emoji = clockEmoji[emojiIndex];
        document.title = `ðŸ¦Š${emoji}`;

        let total = 1000;
        let accumulator = now.getSeconds() * total + now.getMilliseconds();
        total *= 60;
        secondTransform.setRotate((accumulator * 360) / total, 50, 50);
        accumulator += now.getMinutes() * total;
        total *= 60;
        minuteTransform.setRotate((accumulator * 360) / total, 50, 50);
        accumulator += now.getHours() * total;
        total *= 12;
        hourTransform.setRotate((accumulator * 360) / total, 50, 50);

        requestAnimationFrame(updateTime);
      }
      updateTime();

      document.onvisibilitychange = () => {
        worker.postMessage({hidden: document.hidden});
      };

      if (navigator.wakeLock?.request) {
        document.getElementById('wake-lock').style.display = 'flex';
        const toggle = document.getElementById('enable-wake-lock');
        let wakeLock = null;
        toggle.addEventListener('change', async () => {
          if (toggle.checked && !wakeLock) {
            toggle.disabled = true;
            try {
              wakeLock = await navigator.wakeLock.request('screen');
              wakeLock.onrelease = () => {
                toggle.checked = false;
                wakeLock = null;
              }
            } catch (e) {
              console.error("Failed to acquire wake lock!", e);
            } finally {
              toggle.disabled = false;
            }
          } else if (!toggle.checked && wakeLock) {
            wakeLock.release();
            wakeLock = null;
          }
        });
      }

      function toggleFullscreen() {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {
          document.documentElement.requestFullscreen();
        }
      }

      clock.addEventListener('click', toggleFullscreen);
      time.addEventListener('click', toggleFullscreen);
    </script>
  </body>
</html>
