<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="color-scheme" content="dark light">
    <title>ðŸ¦ŠðŸ•’</title>
    <style>
      h1 {
        font-size: 15vw;
        margin: 0;
        text-align: center;
      }
      #time {
        font-family: monospace;
        font-size: 15vw;
        text-align: center;
        margin: 10px 0;
      }
      #status {
        font-family: sans-serif;
        position: fixed;
        bottom: 0;
      }
    </style>
  </head>
  <body>
    <h1 id="title">ðŸ¦ŠðŸ•’</h1>
    <p id="time">??:??:??.?</p>
    <p id="status">
      RTT: <span id="delay">?</span>ms<br>
      Offset: <span id="offset">?</span>ms<br>
    </p>
    <script type="module">
      const clockEmoji = ['ðŸ•›', 'ðŸ•§', 'ðŸ•', 'ðŸ•œ', 'ðŸ•‘', 'ðŸ•', 'ðŸ•’', 'ðŸ•ž',
        'ðŸ•“', 'ðŸ•Ÿ', 'ðŸ•”', 'ðŸ• ', 'ðŸ••', 'ðŸ•¡', 'ðŸ•–', 'ðŸ•£', 'ðŸ•—', 'ðŸ•¢', 'ðŸ•˜',
        'ðŸ•¤', 'ðŸ•™', 'ðŸ•¥', 'ðŸ•š', 'ðŸ•¦'];

      const kNumSamples = 5;
      const kShortDelay = 1000;
      const kLongDelay = 60000;
      let timeoutId = 0;
      const delays = [];
      const timeOrigins = [];
      let timeOrigin = INITIAL_SERVER_TIME - performance.now();

      function average(array) {
        return array.reduce((a, b) => a + b, 0) / array.length;
      }

      async function detectOffset() {
        if (timeOrigins.length >= kNumSamples) {
          delays.shift();
          timeOrigins.shift();
        }

        const request_sent = performance.now();
        const server_time = await (await fetch("/time")).json();
        const response_received = performance.now();

        const newDelay = response_received - request_sent;
        console.log(`Measured round-trip time of ${newDelay.toFixed(2)}ms.`);
        delays.push(newDelay);
        const delay = average(delays);
        document.getElementById('delay').textContent = delay.toFixed(2);

        const newTimeOrigin = ((server_time - request_sent) + (server_time - response_received)) / 2;
        console.log(`Measured time origin of ${newTimeOrigin}.`);
        timeOrigins.push(newTimeOrigin);
        timeOrigin = average(timeOrigins);

        const offset = new Date() - new Date(performance.now() + timeOrigin);
        document.getElementById('offset').textContent = offset;

        if (timeOrigins.length < kNumSamples) {
          timeoutId = setTimeout(detectOffset, kShortDelay);
        } else {
          timeoutId = setTimeout(detectOffset, kLongDelay);
        }
      }

      function updateTime() {
        const now = new Date(performance.now() + timeOrigin);
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        const tenths = Math.floor(now.getMilliseconds() / 100).toString();
        document.getElementById('time').textContent = `${hours}:${minutes}:${seconds}.${tenths}`;

        const emojiIndex = (now.getHours() % 12) * 2 + Math.floor(now.getMinutes() / 30);
        const emoji = clockEmoji[emojiIndex];
        document.title = document.getElementById('title').textContent = `ðŸ¦Š${emoji}`;
        requestAnimationFrame(updateTime);
      }

      updateTime();
      timeoutId = setTimeout(detectOffset, kShortDelay);

      // Avoid taking measurements when the tab is hidden as it could be
      // throttled which will skew RTT measurements.
      document.onvisibilitychange = () => {
        if (document.hidden) {
          console.log("Pausing measurements.");
          clearTimeout(timeoutId);
        } else {
          console.log("Resuming measurements.");
          if (timeOrigins.length < kNumSamples) {
            timeoutId = setTimeout(detectOffset, kShortDelay);
          } else {
            timeoutId = setTimeout(detectOffset, kLongDelay);
          }
        }
      };
    </script>
  </body>
</html>
