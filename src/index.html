<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="color-scheme" content="dark light">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ¦ŠðŸ•’</title>
    <style>
      h1 {
        font-size: 15vw;
        margin: 0;
        text-align: center;
      }
      #time {
        font-family: monospace;
        font-size: 15vw;
        text-align: center;
        margin: 10px 0;
      }
      #status {
        font-family: sans-serif;
        position: fixed;
        bottom: 0;
        left: 0;
        margin: 8;
      }
      #wake-lock {
        font-family: sans-serif;
        position: fixed;
        bottom: 0;
        right: 0;
        margin: 8;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <h1 id="title">ðŸ¦ŠðŸ•’</h1>
    <p id="time">??:??:??.?</p>
    <p id="status">
      RTT: <span id="delay">?</span>ms<br>
      Offset: <span id="offset">?</span>ms<br>
    </p>
    <p id="wake-lock" style="display: none">
      <label for="enable-wake-lock">Keep screen on:</label>
      <input type="checkbox" id="enable-wake-lock">
    </p>
    <script type="module">
      const clockEmoji = ['ðŸ•›', 'ðŸ•§', 'ðŸ•', 'ðŸ•œ', 'ðŸ•‘', 'ðŸ•', 'ðŸ•’', 'ðŸ•ž',
        'ðŸ•“', 'ðŸ•Ÿ', 'ðŸ•”', 'ðŸ• ', 'ðŸ••', 'ðŸ•¡', 'ðŸ•–', 'ðŸ•£', 'ðŸ•—', 'ðŸ•¢', 'ðŸ•˜',
        'ðŸ•¤', 'ðŸ•™', 'ðŸ•¥', 'ðŸ•š', 'ðŸ•¦'];

      const kNumSamples = 5;
      const kShortDelay = 1000;
      const kLongDelay = 60000;
      let timeoutId = 0;
      const delays = [];
      const timeOrigins = [];
      let lastRequest = performance.now();
      let timeOrigin = INITIAL_SERVER_TIME - lastRequest;

      function average(array) {
        return array.reduce((a, b) => a + b, 0) / array.length;
      }

      async function detectOffset() {
        if (timeOrigins.length >= kNumSamples) {
          delays.shift();
          timeOrigins.shift();
        }

        if (performance.now() - lastRequest > 10000) {
          // The socket has probably timed out. Establish a new connection
          // before taking a measurement.
          await fetch('/time');
        }

        const requestSent = performance.now();
        const response = await fetch("/time");
        const responseReceived = performance.now();
        const serverTime = await response.json();
        lastRequest = responseReceived;

        const newDelay = responseReceived - requestSent;
        console.log(`Measured round-trip time of ${newDelay.toFixed(2)}ms.`);
        delays.push(newDelay);
        const delay = average(delays);
        document.getElementById('delay').textContent = delay.toFixed(2);

        const newTimeOrigin = ((serverTime - requestSent) + (serverTime - responseReceived)) / 2;
        console.log(`Measured time origin of ${newTimeOrigin}.`);
        timeOrigins.push(newTimeOrigin);
        timeOrigin = average(timeOrigins);

        const offset = new Date() - new Date(performance.now() + timeOrigin);
        document.getElementById('offset').textContent = offset;

        if (timeOrigins.length < kNumSamples) {
          timeoutId = setTimeout(detectOffset, kShortDelay);
        } else {
          timeoutId = setTimeout(detectOffset, kLongDelay);
        }
      }

      function updateTime() {
        const now = new Date(performance.now() + timeOrigin);
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        const tenths = Math.floor(now.getMilliseconds() / 100).toString();
        document.getElementById('time').textContent = `${hours}:${minutes}:${seconds}.${tenths}`;

        const emojiIndex = (now.getHours() % 12) * 2 + Math.floor(now.getMinutes() / 30);
        const emoji = clockEmoji[emojiIndex];
        document.title = document.getElementById('title').textContent = `ðŸ¦Š${emoji}`;
        requestAnimationFrame(updateTime);
      }

      updateTime();
      timeoutId = setTimeout(detectOffset, kShortDelay);

      // Avoid taking measurements when the tab is hidden as it could be
      // throttled which will skew RTT measurements.
      document.onvisibilitychange = () => {
        if (document.hidden) {
          console.log("Pausing measurements.");
          clearTimeout(timeoutId);
        } else {
          console.log("Resuming measurements.");
          if (timeOrigins.length < kNumSamples) {
            timeoutId = setTimeout(detectOffset, kShortDelay);
          } else {
            timeoutId = setTimeout(detectOffset, kLongDelay);
          }
        }
      };

      if (navigator.wakeLock?.request) {
        document.getElementById('wake-lock').style.display = 'flex';
        const toggle = document.getElementById('enable-wake-lock');
        let wakeLock = null;
        toggle.addEventListener('change', async () => {
          if (toggle.checked && !wakeLock) {
            toggle.disabled = true;
            try {
              wakeLock = await navigator.wakeLock.request('screen');
              wakeLock.onrelease = () => {
                toggle.checked = false;
              }
            } catch (e) {
              console.error("Failed to acquire wake lock!", e);
            } finally {
              toggle.disabled = false;
            }
          } else if (!toggle.checked && wakeLock) {
            wakeLock.release();
            wakeLock = null;
          }
        });
      }
    </script>
  </body>
</html>
